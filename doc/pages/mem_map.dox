/*! \page xram XRAM Layout
    \brief LCD Framebuffer pixel + icons layout

    XRAM is essentially the framebuffer for the VMU.

    |Row/Col |0-7|8-15|16-23|24-31|32-39|40-47|
    |--------|---|----|-----|-----|-----|-----|
    |0, 16   |180|181 |182  |183  |184  |185  |
    |1, 17   |186|187 |188  |189  |18A  |18B  |
    |<center>Skip 4 Bytes</center>|||||||
    |2, 18   |190|191 |192  |193  |194  |195  |
    |3, 19   |196|197 |198  |199  |19A  |19B  |
    |<center>Skip 4 Bytes</center>|||||||
    |4, 20   |1A0|1A1 |1A2  |1A3  |1A4  |1A5  |
    |5, 21   |1A6|1A7 |1A8  |1A9  |1AA  |1AB  |
    |<center>Skip 4 Bytes</center>|||||||
    |6, 22   |1B0|1B1 |1B2  |1B3  |1B4  |1B5  |
    |7, 23   |1B6|1B7 |1B8  |1B9  |1BA  |1BB  |
    |<center>Skip 4 Bytes</center>|||||||
    |8, 24   |1C0|1C1 |1C2  |1C3  |1C4  |1C5  |
    |9, 25   |1C6|1C7 |1C8  |1C9  |1CA  |1CB  |
    |<center>Skip 4 Bytes</center>|||||||
    |10, 26  |1D0|1D1 |1D2  |1D3  |1D4  |1D5  |
    |11, 27  |1D6|1D7 |1D8  |1D9  |1DA  |1DB  |
    |<center>Skip 4 Bytes</center>|||||||
    |12, 28  |1E0|1E1 |1E2  |1E3  |1E4  |1E5  |
    |13, 29  |1E6|1E7 |1E8  |1E9  |1EA  |1EB  |
    |<center>Skip 4 Bytes</center>|||||||
    |14, 30  |1F0|1F1 |1F2  |1F3  |1F4  |1F5  |
    |15, 31  |1F6|1F7 |1F8  |1F9  |1FA  |1FB  |

    Bank 2: 
    |   |7|6   |5|4   |3|2    |1|0    |
    |---|-|----|-|----|-|-----|-|-----|
    |181| |FILE| |    | |     | |     |
    |182| |    | |GAME| |     | |     |
    |183| |    | |    | |CLOCK| |     |
    |184| |    | |    | |     | |FLASH|
  
*/

/*! \page addressing_modes Addressing Modes 
    \brief Listing and details of the LC86K's addressing modes

    Most instructions implicitly operate on some fixed set of SFRs (usually ACC); however, additional operands 
    in either the \link data_space internal RAM or data space \endlink or the \link instruction_space external
    ROM or instruction space \endlink may be specified using one of the addressing modes described below.

|Mnemonic   |Name             |Description                                  
|-----------|-----------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
|\b #i8     |Immediate        |8-bit integer constant encoded within the instruction                                                                                                          |
|\b d9      |Direct           |Arbitrary RAM-space pointer, specified using a 9-bit address                                                                                                   |
|\b @Ri     |Indirect         |Arbitrary RAM-space pointer, specified by combining a stored address, SFR values, and indirection mode (see the next section).                                 |
|\b b3      |Bit Specifier    |A 3-bit integer constant specifying a particular target bit for the instruction. Bit 7 is the MSB, Bit 0 is the LSB.                                           |
|\b a12     |Absolute (12-Bit)|12-bit big endian program location within ROM space. The four most significant bits of the PC remain unaffected, restricting jumping is to within 4k segments. |
|\b a16     |Absolute (16-Bit)|A full 16-bit program location within ROM space, big endian.                                                                                                   |
|\b r8      |Relative (8-Bit) |A program/ROM location specified as a signed relative offset from the next instruction's address.                                                              |
|\b r16     |Relative (16-Bit)|A program/ROM location specified as an unsigned relative offset from the next instruction's address, in little endian byte order.                              |

\subsection indirect_addressing Indirect Addressing
The LC86K CPU has a 16-byte address range which is split into 4 banks of 4 indirect address registers. The bank is chosen 
by setting the two indirect address register bank flags within the PSW (IRBK1, IRBK0). The indirection mode is specified
as part of the instruction, using the @Ri mnemonic. The lower two indirect address modes (@R0-@R1) of each bank specify targets
within RAM, while the upper two indirect address modes (@R2-@R3) specify SFR targets.

The following table illustrates the relationship between IRBK0, IRBK1, the indirection mode, and the source and target addresses:

|IRBK1|IRBK0|Mode|Source Address|Operand Location
|:---:|:---:|:--:|:------------:|:---------------:
|0    |0    |@R0 |000           |RAM (000-0FF)
|^    |^    |@R1 |001           |^
|^    |^    |@R2 |002           |SFR (100-1FF)
|^    |^    |@R3 |003           |^
|0    |1    |@R0 |004           |RAM (000-0FF)
|^    |^    |@R1 |005           |^
|^    |^    |@R2 |006           |SFR (100-1FF)
|^    |^    |@R3 |007           |^
|1    |0    |@R0 |008           |RAM (000-0FF)
|^    |^    |@R1 |009           |^ 
|^    |^    |@R2 |00A           |SFR (100-1FF)
|^    |^    |@R3 |00B           |^
|1    |1    |@R0 |00C           |RAM (000-0FF)
|^    |^    |@R1 |00D           |^ 
|^    |^    |@R2 |00E           |SFR (100-1FF)
|^    |^    |@R3 |00F           |^

The target address when using indirect addressing is given by loading the low byte from a source indirect address register
and combining it with the MSB of the indirection mode as the 9th bit of the target address. The indirect address register
sourced is determined by the state of the IRBK1 and IRBK0 PSW flags as well as the indirection mode specified within the instruction.

*/

/*! \page memory_map Memory Map
    \brief Map of the VMU's various memory spaces

    The VMU is a strange beast with multiple disjoint address spaces for data, instructions, and more. Understanding
    the various segments of the memory map and their layout is required to master the VMU's architecture from a 
    software perspective.
[TOC]

\subsection data_space RAM Memory Space
The following table shows the various segments and banks of the main RAM or the internal data address space. 
This address space is the target of regular data transfer instructions, unless otherwise specified. Spanning
the memory space is XRAM, SFRs, and RAM. XRAM has 3 banks of 64, 64, and 16 bytes respectively. The SFR range 
spans 143 bytes. Main system memory is broken into two banks of 256 bytes each. Bank 0 contains the stack and
is reserved for use by the BIOS and OS routines exclusively. Bank 1 is where the user's generic application
memory resides.
|Address|Bank 0                                         |Bank 1                          |Bank 2      |
|-------|:---------------------------------------------:|:------------------------------:|:----------:|
|1B0-1BF|XRAM - Upper Half of Framebuffer               |XRAM - Lower Half of Framebuffer|UNUSED      |
|1A0-1AF|^                                              |^                               |^           |
|190-19F|^                                              |^                               |^           |
|180-18F|^                                              |^                               |XRAM - Icons|
|170-17F|\link sfrs Special Function Registers \endlink |UNUSED                          |UNUSED      |
|160-16F|^                                              |^                               |^           |
|150-15F|^                                              |^                               |^           |
|140-14F|^                                              |^                               |^           |
|130-13F|^                                              |^                               |^           |
|120-12F|^                                              |^                               |^           |
|110-11F|^                                              |^                               |^           |
|100-10F|^                                              |^                               |^           |
|0F0-0FF|Stack Area                                     |Application/User RAM            |^           |
|0E0-0EF|^                                              |^                               |^           |
|0D0-0DF|^                                              |^                               |^           |
|0C0-0CF|^                                              |^                               |^           | 
|0B0-0BF|^                                              |^                               |^           |
|0A0-0AF|^                                              |^                               |^           |
|090-09F|^                                              |^                               |^           |
|080-08F|\link system_variables System/BIOS RAM \endlink|^                               |^           |
|070-07F|^                                              |^                               |^           | 
|060-06F|^                                              |^                               |^           |
|050-05F|^                                              |^                               |^           |
|040-04F|^                                              |^                               |^           |
|030-03F|^                                              |^                               |^           |
|020-02F|^                                              |^                               |^           |
|010-01F|^                                              |^                               |^           |
|000-00F|^                                              |^                               |^           |

\subsection instruction_space ROM Memory Space
Due to the fact that the VMU can execute either directly from the BIOS, residing on a built-in ROM chip,
or from a GAME user application residing in flash, the device treats the instruction space as a generic
memory space, which can swap between sourcing instructions between ROM and flash depending on the CPU state.
ROM is a single chip spanning 64KB of space, while flash is 2 banks of 64KB each. 

|Address  |ROM                  |Flash (Bank 0)        |Flash (Bank 1)
|---------|---------------------|----------------------|------------------------
|F0FF-FFFF|UNUSED               |For GAME/DATA Use     |For DATA Use Only
|E000-EFFF|OS Program Area      |^                     |^
|4000-DFFF|Reserved Area        |^                     |^
|0000-3FFF|System Program Area  |^                     |^

\subsection wram Work RAM
Work RAM is an additional, separate memory space from main RAM. It offers the VMU an additional 512 bytes which
can be utilized as more general-purpose storage when in standalone mode. While connected to a Dreamcast, this 
storage functions as a Maple TX/RX packet buffer for the Maple communications stack. WRAM is accessed one byte
at a time, with a target address given by the two VRMAD SFRs, and read/writes being issued via accessing the 
VTRBF SFR.

|Address|Description                     |
|-------|--------------------------------|
|1FF    |512 Bytes Additional Work RAM   |
|...    |^                               |
|000    |^                               |

*/

/*! \page system_variables System Variables
    \brief Listing of all known system variables with their description
\warning 
These values are not meant to be manipulated by the user, so writing invalid data to them can cause system instability.

|Address  |Name                             |Description                             |
|--------:|:--------------------------------|----------------------------------------|
|<center><b>Date & Time</b></center>|||
|10|\link EVMU_ADDRESS_SYSTEM_YEAR_MSB_BCD  |BCD-Encoded Century (first two digits)  |
|11|\link EVMU_ADDRESS_SYSTEM_YEAR_LSB_BCD  |BCD-Encoded Year (last two digits)      |         
|12|\link EVMU_ADDRESS_SYSTEM_MONTH_BCD     |BCD-Encoded Month (1-12)                |
|13|\link EVMU_ADDRESS_SYSTEM_DAY_BCD       |BCD-Encoded Day (1-31)                  |
|14|\link EVMU_ADDRESS_SYSTEM_HOUR_BCD      |BCD-Encoded Hour (0-23)                 |
|15|\link EVMU_ADDRESS_SYSTEM_MINUTE_BCD    |BCD-Encoded Minute (0-59)               |
|16|\link EVMU_ADDRESS_SYSTEM_SEC_BCD       |BCD-Encoded Second (0-59)               |
|17|\link EVMU_ADDRESS_SYSTEM_YEAR_MSB      |Century (first two digits)              |
|18|\link EVMU_ADDRESS_SYSTEM_YEAR_LSB      |Year (last two digits)                  |
|19|\link EVMU_ADDRESS_SYSTEM_MONTH         |Month (1-12)                            |
|1A|\link EVMU_ADDRESS_SYSTEM_DAY           |Day (1-31)                              |
|1B|\link EVMU_ADDRESS_SYSTEM_HOUR          |Hour (0-59)                             |
|1C|\link EVMU_ADDRESS_SYSTEM_MINUTE        |Minute (0-59)                           |
|1D|\link EVMU_ADDRESS_SYSTEM_SEC           |Second (0-59)                           |
|1E|\link EVMU_ADDRESS_SYSTEM_HALF_SEC      |Half Second (0-1)                       |
|1F|\link EVMU_ADDRESS_SYSTEM_LEAP_YEAR     |Leap Year (0 = no, 1 = yes)             |
|<center><b>General</b></center>|||
|30|\link EVMU_ADDRESS_SYSTEM_MODE          |Index for BIOS Mode                     |
|31|\link EVMU_ADDRESS_DATE_SET             |Date/Time Valid (0x0 = no, 0xFF = yes)  |
|50|\link EVMU_ADDRESS_SYSTEM_QUART_YEAR_MSB|Quarter Year MSB                        |
|51|\link EVMU_ADDRESS_SYSTEM_QUART_YEAR_LSB|Quarter Year LSB                        |
|60|\link EVMU_ADDRESS_SYSTEM_CURSOR_POS_COL|Menu Cursor column position             |
|61|\link EVMU_ADDRESS_SYSTEM_CURSOR_POS_ROW|Menu Cursor row position                |
|6D|\link EVMU_ADDRESS_SYSTEM_GAME_LAST_BLK |Last block used by minigame             |
|6E|\link EVMU_ADDRESS_SYSTEM_BATTERY_CHECK |Check Low battery (0x0 = yes, 0xFF = no)|
|<center><b>Stack</b></center>|||
|80|\link EVMU_ADDRESS_SYSTEM_STACK_BASE    |First stack location                    |
|81-FE|<center>Middle Stack</center>||
|FF|\link EVMU_ADDRESS_SYSTEM_STACK_END     |Last stack location                     |
*/

/*! \page sfrs Special Function Registers
    \brief Listing and information on all known SFRs
\section sfr_memory_space Memory Space
Address|Name                               |Description                             |
------:|:----------------------------------|----------------------------------------|
<center><b>CPU</b></center>|||
100|<a href="#acc"><b>ACC</b></a>          |Accumulator                             |
101|<a href="#psw"><b>PSW</b></a>          |Program Status Word                     |         
102|<a href="#b"><b>B</b></a>              |B Register                              |
103|<a href="#c"><b>C</b></a>              |C Register                              |
104|<a href="#trl"><b>TRL</b></a>          |Table Reference (Low Byte)              |
105|<a href="#trh"><b>TRH</b></a>          |Table Reference (High Byte)             |
106|<a href="#sp"><b>SP</b></a>            |Stack Pointer                           |
107|<a href="#pcon"><b>PCON</b></a>        |Power Control                           |
108|<a href="#ie"><b>IE</b></a>            |Interrupt Enable Control                |
109|<a href="#ip"><b>IP</b></a>            |Interrupt Priority Control              |
10A|<center>UNUSED</center>||
10B|^||                 
10C|^||
10D|<a href="#ext"><b>EXT</b></a>          |External Memory Control                 |
10E|<a href="#ocr"><b>OCR</b></a>          |Oscillation Control Register            |
10F|<center>UNUSED</center>||
<center><b>Timer 0</b></center>|||
110|<a href="#t0cnt"><b>T0CNT</b></a>      |Timer 0 Control                         |
111|<a href="#t0prr"><b>T0PRR</b></a>      |Timer 0 Prescalar Reload                |
112|<a href="#t0l"><b>T0L</b></a>          |Timer 0 Low Byte                        |
113|<a href="#t0lr"><b>T0LR</b></a>        |Timer 0 Low Byte Reload                 |
114|<a href="#t0h"><b>T0H</b></a>          |Timer 0 High Byte                       |
115|<a href="#t0hr"><b>T0HR</b></a>        |Timer 0 High Byte Reload                |
116|<center>UNUSED</center>||
117|^||
<center><b>Timer 1</b></center>|||
118|<b>T1CNT</b>                           |Timer 1 Control                         |
119|<center>UNUSED</center>||
11A|<b>T1LC</b>                            |Timer 1 Low Compare Data                |
11B|<b>T1L</b>                             |Timer 1 Low Byte                        |
11C|<b>T1HC</b>                            |Timer 1 High Compare Data               |
11D|<b>T1H</b>                             |Timer 1 High Byte                       |
11E|<center>UNUSED</center>||
11F|^||
<center><b>LCD Screen</b></center>|||
120|\b MCR                                 |Mode Control                            |
121|<center>UNUSED</center>||
122|\b STAD                                |Start Address                           |
123|\b CNR                                 |Character Number Register               |
124|\b TDR                                 |Time Division Register                  |
125|\b XBNK                                |XRAM Bank Address                       |
126|<center>UNUSED</center>||
127|\b VCCR                                |LCD Contrast Control Register           |
128|<center>UNUSED</center>||
129|^||
12A|^||
12B|^||
12C|^||
12D|^||
12E|^||
12F|^||
<center><b>Serial Interface 0</b></center>|||
130|\b SCON0                               |SIO0 Control                            |
131|\b SBUF0                               |SIO0 Buffer                             |
132|\b SBR                                 |SIO Baud Rate Generator                 |
133|<center>UNUSED</center>||
<center><b>Serial Interface 1</b></center>|||
134|\b SCON1                               |SIO1 Control                            |
135|\b SBUF1                               |SIO1 Buffer                             |
136|<center>UNUSED</center>||
137|^||
138|^||
139|^||
13A|^||
13B|^||
13C|^||
13D|^||
13E|^||
13F|^||
140|^||
141|^||
142|^||
143|^||
<center><b>Port 1</b></center>|||
144|\b P1                                 |Port 1 Latch                             |
145|\b P1DDR                              |Port 1 Data Direction Register           |
146|\b P1FCR                              |Port 1 Function Control Register         |
147|\b ?                                  |Bits[0-6]: Logic High, Bit[7]: R/W       |
148|\b ?                                  |BIOS writes once with 0x00 on startup    |
149|<center>UNUSED</center>||
14A|^||
14B|^||
<center><b>Port 3</b></center>|||
14C|\b P3                                 |Port 3 Latch                             |
14D|\b P3DDR                              |Port 3 Data Direction Register           |
14E|\b P3INT                              |Port 3 Interrupt Control                 |
14F|<center>UNUSED</center>||
150|^||
151|\b ?                                  |BIOS sets bit 5 only                     |
152|UNUSED||
153|^||
<center><b>Flash</b></center>|||
154|\b FPR                                |Flash Program Register                   |
155|\b ?                                  |BIOS writes once with 0xFF               |
156|<center>UNUSED</center>||
157|^||
158|^||
159|^||
15A|^||
15B|^||
<center><b>Port 7</b></center>|||
15C|\b P7                                 |Port 7 Latch                             |
15D|\b I01CR                              |External Interrupt 0, 1 Control          |
15E|\b I23CR                              |External Interrupt 2, 3 Control          |
15F|\b ISL                                |Input SIgnal Selection                   |
<center><b>Maple</b></center>|||
160|\b MPLSW                              |Maple Status Word                        |
161|\b MPLSTA                             |Maple Start Transfer                     |
162|\b MPLRST                             |Maple Reset                              |
<center><b>Work RAM</b></center>|||
163|\b VSEL                               |VMS Control Registers                    |
164|\b VRMAD1                             |Work RAM Access Address 1                |
165|\b VRMAD2                             |Work RAM Access Address 2                |
166|\b VTRBF                              |Send/Receive Buffer                      |
167|\b VLREG                              |Maple Word Length Registration           |
168|<center>UNUSED</center>||
169|^||
16A|^||
16B|^||
16C|^||
16D|^||
16E|^||
16F|^||
170|^||
171|^||
172|^||
173|^||
174|^||
175|^||
176|^||
177|^||
178|^||
179|^||
17A|^||
17B|^||
17C|^||
17D|^||
17E|^||
<center><b>Base Timer</b></center>|||
17F|\b BTCR                             |Base Time Control Register                |

\section cpu_sfrs CPU
\subsection acc [0x100] ACC: Accumulator
<p>8-bit register used as the implicit target register for most instructions and operations, such as arithmetic computation, transfers, I/O, and more.</p>

\subsection psw [0x101] PSW: Program Status Word
<p>PSW consists of flags for the results of arithmetic instruction execution as well as for specifying RAM banks and indirect address registers.</p>
|7 |6 |5|4    |3    |2 |1     |0|
|--|--|-|-----|-----|--|------|-|
|CY|AC| |IRBK1|IRBK0|OV|RAMBK0|P|

<p><b>CY (bit 7): Carry Flag</b><br>
Set when carrying from the MSB after an addition or when a borrow to the MSB occurs after an addition. Otherwise, the flag is reset. The flag is also modified by rotation instruction staht include CY.</p>

<p><b>AC (bit 6): Auxiliary Carry Flag</b><br>
Set when bit 3 of the accumulator propagates over to the next higher digit as a carry or to the next lower digit as a borrow. Otherwise it is reset.</p>

<p><b>IRBKx (bits 3-4): Indirect Address Register Bank</b><br>
Specifies which of the 4 register banks to use as indirect address registers when using indirect addressing. See \ref indirect_addressing for more information.</p>

<p><b>OV (bit 2): Overflow Flag</b><br>
Set when an overflow occurs in addition or subtraction. Also set when the result of a multiplication is greater than 256 or division by zero is performed.</p>

<p><b>RAMBK0 (bit 1): Ram Bank</b><br>
Specifies the current RAM bank for data access. Bank 0 contains the stack and is reserved for use by the system BIOS while Bank 1 is general purpose application RAM. See \ref memory_map for more information.</p>

<p><b>P (bit 0): Parity Flag</b><br>
Set when the total number of bits set within the accumulator is an odd number. Reset to 0 when the total number of bits set within the accumulator is even. Read-only.</p>

\subsection b [0x102] B: B Register
<p>Used in combination with ACC and the C Register for sourcing and storing data with arithmetic operations.</p>

\subsection c [0x103] C: C Register
<p>Used in combination with ACC and the B Register for sourcing and storing data with arithmetic operations.</p>

\subsection trl [0x104] TRL: Table Reference Register (Low Byte)
\subsection trh [0x105] TRH: Table Reference Register (High Byte)
<p>TRL and TRH combine to form a single 16-bit register, TRR, which is used for ROM and flash addressing. The LDC instruction adds TRR register to the value stored within the ACC to form a target address for loading data into the accumulator. The BIOS's flash subroutines (read/write) also use TRR for determining which address to target within the specified bank. 

\subsection sp [0x106] TRL: Stack Pointer
Used to point to the last filled address within the stack region of RAM bank 0. It is incremented before moving data onto the stack with a PUSH instruction and is decremented after fetching data from the stack with the POP instruction. 

\subsection pcon [0x107] PCON: Power Control
Used to suspend the CPU and its peripherals to reduce power consumption. These bits are automatically reset when execution is resumed.
|7|6|5|4|3|2|1   |0   |
|-|-|-|-|-|-|----|----|
| | | | | | |HOLD|HALT|
<p><b>HOLD (bit 1): Suspend CPU and Timers</b><br>
When set to 1, puts the VMU into a deep sleep, stopping the CPU, all timers, and all oscillators. Only an external interrupt or reset will cause operations to resume. Not in the official documents and will cause the BIOS to no longer maintain the proper time, since the base timer is halted.
</p>

<p><b>HALT (bit 0): Halt CPU</b><br>
When set to 1, stops CPU instruction exection while allowing timers and all other peripherals to continue operating normally. Any interrupt will wake the CPU up and break resume execution.
</p>

\subsection ie [0x108] IE: Interrupt Enable Control
|7  |6|5|4|3|2|1  |0  |
|---|-|-|-|-|-|---|---|
|IE7| | | | | |IE1|IE0|
<p><b>IE7 (bit 7): Master Interupt Enable</b><br>
When set to 1, all interrupt requests are enabled. When reset to 0, "high" and "low" priority interrupts are disabled.</p>
<p><b>IE1-IE0 (bits 1-0): Interrupt Priority Control</b><br>
Sets the priority level of external interrupts INT1 and INT0:<br>
|IE1|IE0|INT1 Priority|INT0 Priority|
|---|---|-------------|-------------|
|0  |0  |Highest      |Highest      |
|1  |0  |Low          |Highest      |
|X  |1  |Low          |Low          |
</p>

\subsection ip [0x109] IP: Interrupt Priority Control
<p>Provides flags for controlling whether interrupts are given LOW or HIGH priority ranking</p>
|7  |6  |5  |4  |3  |2  |1  |0  |
|---|---|---|---|---|---|---|---|
|IP7|IP6|IP5|IP4|IP3|IP2|IP1|IP0|
<p><b>IP7 (bit 7): P3 Interrupt Priority</b><br>
Sets the priority for Port 3 interrupts. 0: Low, 1: High.</p>
<p><b>IP6 (bit 6): Maple Interrupt Priority</b><br>
Sets the priority for Maple interrupts. 0: Low, 1: High.
\warning
This is an undocumented bitfield which was most likely intentionally hidden. While its behavior has yet to be confirmed, this hole perfectly aligns with the location of the Maple interrupt which was also undocumented.</p>
<p><b>IP5 (bit 5): SIO1 Interrupt Priority</b><br>
Sets the priority for Serial I/O 1 interrupts. 0: Low, 1: High.</p>
<p><b>IP4 (bit 4): SIO0 Interrupt Priority</b><br>
Sets the priority for Serial I/O 0 interrupts. 0: Low, 1: High.</p>
<p><b>IP3 (bit 3): T1 Interrupt Priority</b><br>
Sets the priority for Timer 1 interrupts. 0: Low, 1: High.</p>
<p><b>IP2 (bit 2): T0H Interrupt Priority</b><br>
Sets the priority for Timer 0 High overflow interrupts. 0: Low, 1: High.</p>
<p><b>IP1 (bit 1): INT3/Base Timer Interrupt Priority</b><br>
Sets the priority for Internal Interrupt Source 3 and Base Timer interrupts. 0: Low, 1: High.</p>
<p><b>IP0 (bit 0): INT2/T0L Interrupt Priority</b><br>
Sets the priority for Internal Interrupt Source 2 and Timer 0 Low overflow interrupts. 0: Low, 1: High.</p>

\subsection ext [0x10D] EXT: External Memory Control
<p>Controls the source and base address of ROM memory space accesses.</p>
\warning
This register was intentionally left undocumented in the hardware documentation
and was never meant to be modified directly.

|7|6|5|4|3   |2   |1     |0   |
|-|-|-|-|----|----|------|----|
| | | | |EXT3|EXT2|LDCEXT|EXT0|

<p><b>EXT3 (bit 3): External Bank Address</b><br>
Controls which 64KB bank is selected for the ROM source.</p>
<p><b>EXT2 (bit 2): ?</b><br>
Undocumented flag.
<p><b>LDCEXT (bit 1): LDC Instruction Source?</b><br>
Hardware docs say:</p>
\note
[If the applicaton is running], "the system switches from the application (game mode) to the system program.
However, if bit 1 (LDCEXT) of the external memory control register is set, the CHANGE instruction will not cause
a change to the system program. The application continues to run."
<p><b>EXT0 (bit 0): ?</b><br>
Undocumented flag.</p>

\subsection ocr [0x10E] OCR: Oscillation Control Register
<p>Controls power to the oscillators and determine which is used by the system clock.</p>

|7   |6|5   |4   |3|2|1   |0   |
|----|-|----|----|-|-|----|----|
|OCR7| |SYSCLK|| | |OCR1|OCR0|

<p><b>OCR 7 (bit 7): System Clock Divider</b><br>
When set to 1 (default), the system clock frequency is divided by 6. When reset to 0, its divided by 12.</p>
<p><b>SYSCLK (bits 5-4): System Clock Selector</b><br>
Selects the system clock source based on the values in the following table:</p>
|OCR5|OCR4|Source Oscillator|
|----|----|-----------------|
|0   |0   |RC               |
|0   |1   |CF               |
|1   |0   |Quartz           |
|1   |1   |CF               |
<p><b>OCR1 (bit 1): RC Oscillator Control</b><br>
When set to 1, the RC oscillator is disabled, preserving power. When reset to 0, it is enabled.</p>
<p><b>OCR0 (bit 0): CF Oscillator Control</b><br>
When set to 1 (default), the CF oscillator ceases operation. When reset to 0 (as when the VMU is docked), it begins to operate.</p>

\warning
It has been proven that the CF oscillator, which is usually used when the VMU is docked in the controller, can be enabled while running in standalone GAME mode. However, this drains the batteries quickly. Look into buying a AA battery supply adapter, USB power cable mod, or rechargeabel LIR2032s if this is an issue and you wish to use this clock source. 

\note
The VMU hardware docs make mention of not disabling the Quartz oscillator, so I'm assuming perhaps OCR2 is the control flag for it?

\subsection t0cnt [0x14E] T0CNT: Timer 0 Control
<p>Configures and controls the operation of the Timer 0 peripheral</p>

|7     |6     |5     |4     |3     |2    |1     |0    |
|------|------|------|------|------|-----|------|-----|
|T0HRUN|T0LRUN|T0LONG|T0LEXT|T0HOVF|T0HIE|T0LOVF|T0LIE|

<p><b>T0HRUN (bit 7): Timer 0 High Count Control</b><br>
Setting this flag to 1 starts the T0H counter by supplying the clock to it. Resetting it to 0 stops counting and reloads T0H with T0HR.</p>

<p><b>T0LRUN (bit 6): Timer 0 Low Count Control</b><br>
Setting this flag to 1 starts the T0L counter by supplying the clock to it. Resetting it to 0 stops counting and reloads T0L with T0LR.</p>

<p><b>T0LONG (bit 5): Timer 0 Bit Length Specifier</b><br>
When set to 1, 16-bit mode is used. When reset to 0, 8-bit mode used.</p>

<p><b>T0LEXT (bit 4): Timer 0 Low Input Clock Select</b><br>
Specifies the clock supplied to T0L. When set to 1, it is driven by an external input signal (source determined by ISL). When reset to 0, the prescalar output is selected.</p>

<p><b>T0HOVF (bit 3): Timer 0 High Overflow Flag</b><br>
This flag is set whenever T0H overflows and otherwise never changes. It must be reset by the interrupt handler or application.</p>

<p><b>T0HIE (bit 2): Timer 0 High Interrupt Enable</b><br>
Enables or disables generation of interrupt requests upon T0H overflow. When set to 1, the T0H interrupt vector (0x0023) is used. When reset to zero, no request is generated.</p>

<p><b>T0LOVF (bit 1): Timer 0 Low Overflow Flag</b><br>
This flag is set whenever T0L overflows and otherwise never changes. It must be reset by the interrupt handler or application. This flag is not used when in 16-bit mode.</p>

<p><b>T0LIE (bit 0): Timer 0 Low Interrupt Enable</b><br>
Enables or disables generation of interrupt requests upon T0L overflow. When set to 1, the T0L interrupt vector (0x0013) is used. When reset to zero, no request is generated.</p>

\subsection t0prr [0x111] T0PRR: Timer 0 Prescalar Reload
<p>Stores the reload value for the Timer 0 prescalar register (TPR).</p>

\subsection t0l [0x112] T0L: Timer 0 Low Byte
<p>Read-only register storing the current value of either the first independently operating 8-bit counter/timer of Timer 0, or the low byte of the combined 16-bit counter/timer of Timer 0, depending on the current <a href="#t0cnt">T0CNT</a> configuration</p>

\subsection t0lr [0x113] T0LR: Timer 0 Reload 
<p>The value used to reload the T0L timer/counter is stored within this register. When using 8-bit mode, its contents are reloaded into T0L upon overflow.</p>

\subsection t0h [0x114] T0H: Timer 0 High Byte
<p>Read-only register storing hte current value of either the second independently operating 8-bit counter/timer of Timer 0, or the high byte of the combined 16-bit counter/timer of Timer 0, depending on the current <a href="#t0cnt">T0CNT</a> configuration.</p>

\subsection t0hr [0x115] T0HR: Timer 0 High Reload
<p>The value used to reload the T0H timer/counter is stored within this register. Upon overflow, its contents are loaded into T0H.</p>
*/